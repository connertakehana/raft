What is raft?
A conensus algo -> Multiple machines can maintain identical info abt state even when some machines fail
Implementaiton overview:
    Servers can have 3 states: followers, candidate, leader
    Followers simply listen to commands given to by leaders
    Candidate try to become leaders through elections
    Leaders recieve client commands, and tell followers what to do


——————————————————————————————————————————————FOLLOWER——————————————————————————————————————————————
As a follower, 3 things can happen:
    1) Recieve AppendEntries command from a leader
        if term number smaller, reject
        if higher term number, update local term
            Update local leaderID
        If matching, prevLogIndex + prevLogTerm
            replace logs. check for leader commitIndex and do commits
        if not matching, 
            reject
    2) Recieves requestVote
        Either accept or deny
    3) Heartbeat timer runs out (nothing from leader/candidates), forcing follower to become candidate

To setup a new follower:
    current_term = 0
    voted_for = null
    logs = []
    commit_index = 0
    last_applied = 0
    leader_timeout = some random number


Transition from candidate -> follower:
    current_term = candidate.current_term
    voted_for = candidate.voted_for
    logs = candidate.logs
    commit_index = candidate.commit_index
    last_applied = candidate.last_applied
    heartbeat_reset = some random number


Transition from leader -> follower:


Follower code layout:
x threads running:
    thread 1 (timeout waiter): 
        is sleeping most of time
        wakes up from time to time to see if no heartbeats recently
        if so, closes all other threads and turns to candidate
    thread 2 (logic block):
        recieves and sends apepdnentries/requestVote
    
        


——————————————————————————————————————————————CANDIDATE——————————————————————————————————————————————
As a candidate, 4 things can happen:
    1) Recieves AppendEntries from another leader
        if term >=, become follower, if <, return false for them, ignore
    2) Recieves RequestVote
        if term >, demote to follower and respond yes. otherwise, say false
    3) Recieves RequestVote responses
        if given term that is higher, become follower
        if more than majority trues (including self), become leader
    4) Don't win + noone becomes leader from some "timer" amnt of time
        Upgrade term, retry candidacy

——————————————————————————————————————————————LEADER——————————————————————————————————————————————
As a leader, x things can happen:
    1) Recieve client request
        Append command to log, issue AppendEntries RPC to everyone
        Keeps bothering each machine w/ an AppendEntries untill they respond so log is replicated, even after a log has been commited by majority
    2) Recieves AppendEntries response true
        Update for that server the highest log entry known to be updated
        Update commitindex if needed
    3) Recieves AppendEntries resonse false
        Add another log to the messege
        Decremnt nextIndex for that server to the correct one
        
    




——————————————————————————————————————————————THE HANDLER——————————————————————————————————————————————
Need a mechanism to switch between follower, candidate, leader
Everyone starts at follower
When follower timeout runs out, they need to become candidate

Server pointer = new follower
server_type current_type = FOLLOWER;
server_type switch_to = trun_follower(pointer)
while true:
    server_type new_switch = run_thing(pointer, current_type, switch_to)
    current_type = switch_to;
    switch_to = new_switch


